# Bulls and Cows AI

This is a matlab program I wrote for an engineering class in 2011 while at Trinity College. It plays a version of the Bulls and Cows game in which only the number of Bulls are revealed. It wins after about 7.8 tries, with a standard deviation of about 1.38. 

### How to use

To run, navigate to the directory after cloning it and type "run Bulls_and_cows_main" in the matlab command line. A sample "randomDigits.txt" file is provided to supply the numbers the program will try to guess. If you want to supply your own random numbers, simply edit this file.

### The Game

A synopsis of the game can be found [on wikipedia](https://en.wikipedia.org/wiki/Bulls_and_Cows). In this particular version, the goal is to guess a 4 digit number in as few guesses as possible. After each guess, the computer is told how many digits are correct. Once all the digits are guessed, the game ends.

### The Algorithm

This algorithm was developed independently of any research and there was no formal math done, so I don't know how it stacks up against other algorithm. A rough explanation, which was written and submitted with the assignment, is copied below:

##### Explanation

The first two guesses were set to always be [1,2,3,4] and [5,6,7,8], respectively. Based on the results of these guesses, I came up with a discreet number of scenarios. For example, you could have 2 correct in the first guess and 1 correct in the second (this would be a 2v1 or 1v2 scenario). For this evaluation, order was not important, so X correct means the sum of bulls and cows added up to X.

For each scenario, the possible answers were calculated by combining a certain number from the first guess to a certain number from the second guess and a certain number from the remaining numbers (9 and 0), if there were any (which depends on the scenario). For example, in a 2v1, all combinations would be made by combining 2 numbers from [1,2,3,4], 1 number from [5,6,7,8] and 1 number from [9,0]. In a 2v2, all combinations would be made by combining 2 numbers from [1,2,3,4] and 2 numbers from [5,6,7,8]. 

For the first guess in each scenario, or the third guess in total, the first possible answer for the scenario was used as a guess. The change_order4 function, which is used from this point on, was implemented at the end of each guess for each scenario to change the order so it did not share any digits in the same spots as in the previous guess (for example, if the previous guess was [5,6,7,8] and the first possible combination for the new guess was said to be [1,0,5,6], the order would be changed to [5,6,1,0], or a similar permutation). This was used to give us better results for the final_eval function, which I will explain later. The results of that guess were then used to eliminate the possible answers which, when compared to the guess, did not yield the same results. Again, comparing order was not important at this point (saves speed and a headache); an answer was considered to be valid if, when compared to the guess, it had the same number of shared digits as the real answer when compared to the guess.

After this was completed, each answer in the new list of possible answers was given a “type”, which was used to find the most efficient use of a next guess. A “type” for an answer was determined by comparing the components (the components are called A and B, and are based on ¬¬¬the possible numbers which could have been correct for the very first guess and the possible numbers which could have been correct for the second guess) of the answer to the guess and evaluating whether the guess, based on the components, was wrong (W) partially right (P) or right (R). For example, if the guess was [5,6,1,0] and a possible answer was [5,7,2,9], the type would be P,W. This is because [5,6], the A component of [5,6,1,0],  shares only 1 correct digit with [5,7], which the A component of [5,7,2,9]; and [1], the B component of [5,6,1,0], shares no correct digits with [2], which is the B component of [5,7,2,9]. Partials were only significant when the component had 2 digits, as these were the only type of components in which a type W means you could invert the guess (this is explained more in the program). Based on the possible types in the possible answers, a new guess was made using logic specific to the possible types and the scenario. However, because the options for making a new guess were finite and fairly limited (all combinations of keeping, inverting, or using next for two different components, which adds up to 9), this was not too difficult. This process was then repeated until all the numbers in the guess were correct.

After this, the function final_eval was used for the last few guesses to calculate the correct order. To do so, the number of bulls in all the guesses were calculated and compiled into a list. Based on that list, all permutations of the guess with all four correct digits (the last in the list), were compared to the guesses previously made, and all the permutations which did not match up with the results for the previous guesses were eliminated. Because the order of each guess was deliberately changed to be as different from the last as possible, this only took an average of 1 extra guess. In addition, since the order was not changed until the final step, the amount of possible permutations calculated earlier in the program was significantly less that had I evaluated it in the first few steps, and the program runs very quickly.
